
DECLARE FUNCTION fPIDINIT1 {
  DECLARE PARAMETER vKP.
	DECLARE PARAMETER vKI.
	DECLARE PARAMETER vKD.

  DECLARE vSeekP TO 0. 		// DESIRED VALUE FOR P (WILL GET SET LATER).
  DECLARE vP TO 0.     		// PHENOMENON P BEING AFFECTED.
  DECLARE vI TO 0.     		// CRUDE APPROXIMATION OF INTEGRAL OF P.
  DECLARE vD TO 0.     		// CRUDE APPROXIMATION OF DERIVATIVE OF P.
  DECLARE vOldT TO -1. 		// (OLD TIME) START VALUE FLAGS THE FACT THAT IT HASN'T BEEN CALCULATED
  DECLARE vOldInput TO 0. // PREVIOUS RETURN VALUE OF PID CONTROLLER.

  // BECAUSE WE DON'T HAVE PROPER USER STRUCTURES IN KOS (YET?)
  // I'LL STORE THE PID TRACKING VALUES IN A LIST LIKE SO:
  
  DECLARE vPID_Array TO LIST().
  vPID_Array:ADD(vKP).    		// [0]
  vPID_Array:ADD(vKI).    		// [1]
  vPID_Array:ADD(vKD).    		// [2]
  vPID_Array:ADD(vSeekP). 		// [3]
  vPID_Array:ADD(vP).     		// [4]
  vPID_Array:ADD(vI).     		// [5]
  vPID_Array:ADD(vD).     		// [6]
  vPID_Array:ADD(vOldT).  		// [7]
  vPID_Array:ADD(vOldInput). 	// [8].

  RETURN vPID_Array.
}.

// GIVEN A LIST OF THE TUNING PARAMS MADE WITH PID_INIT, AND THE DESIRED VALUE OF THE PHENOMENON, AND THE CURRENT VALUE
// FOR THE PHENOMENON, IT WILL AUTOMATICALLY RETURN WHAT YOU SHOULD SET THE CONTROLLING THING FOR THAT PHENOMENON TO.
DECLARE FUNCTION fPIDSEEK1 {
  DECLARE PARAMETER vPID_Array.
	DECLARE PARAMETER vSeekValue.
	DECLARE PARAMETER vCurrentValue.
	
  // WE HAVE NO "STATIC LOCALS" SO I'M DOING A TRICK HERE. SINCE LIST()S ARE PASSED BY REF INSTEAD OF BY VALUE,
  // STORE THE DATA NEEDED BETWEEN CALLS IN THE LIST(), SO IT GETS PERSISTED BETWEEN CALLS OF ME.

  DECLARE vKP   TO vPID_Array[0].
  DECLARE vKI   TO vPID_Array[1].
  DECLARE vKD   TO vPID_Array[2].
  DECLARE vOldS TO vPID_Array[3]. 
  DECLARE vOldP TO vPID_Array[4].
  DECLARE vOldI TO vPID_Array[5].
  DECLARE vOldD TO vPID_Array[6].
  DECLARE vOldT TO vPID_Array[7].
  DECLARE vOldInput TO vPID_Array[8].

  DECLARE vP TO vSeekValue - vCurrentValue.
	// SET DEFAULTS INCASE NOTHING TO DO THIS TIME ROUND
  DECLARE vD TO 0. 		
  DECLARE vI TO 0. 
  DECLARE vNewInput TO vOldInput.

  DECLARE vT TO TIME:SECONDS.
  DECLARE vDT TO vT - vOldT.

  IF vOldT < 0 {
    // I HAVE NEVER BEEN CALLED YET - SO DON'T TRUST ANY OF THE SETTINGS YET.
  } ELSE {	
    IF vDT = 0 { 
			// DO NOTHING IF NO PHYSICS TICK HAS PASSED FROM PREV CALL TO NOW.
      SET vNewInput TO vOldInput.
    } ELSE {
      SET vD TO (vP - vOldP)/vDT. 	// CRUDE FAKE DERIVATIVE OF P
      SET vI TO (vOldI + vP)*vDT.		// CRUDE FAKE INTEGRAL OF P
      SET vNewInput TO vKP*vP + vKI*vI + vKD*vD.
    }.
  }.

  // REMEMBER OLD VALUES FOR NEXT TIME.
  SET vPID_Array[3] TO vSeekValue.
  SET vPID_Array[4] TO vP.
  SET vPID_Array[5] TO vI.
  SET vPID_Array[6] TO vD.
  SET vPID_Array[7] TO vT.
  SET vPID_Array[8] TO vNewInput.

  RETURN vNewInput.
}.

